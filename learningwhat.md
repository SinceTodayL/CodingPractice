

### Recording Learning What In The Process Of Coding & Good Problems



#### 2025 0227 cf_eduround175 div2

B题是模拟

C题是一个二分，非常巧妙的转换了问题，原本是：

在给定 k 下求最小 x，

现在用二分 x 的方法将问题转化成：

在给定 x 的情况下，求 k 是否能满足条件 (bool返回值的check函数)

妙哉

#### 2025 0302 cf_round1007 div2

B题，`for` 循环中的 i 要用 longlong，不然后面 i * (i + 1) 就会爆int

不开longlong见祖宗

#### 2025 0307 cf_round1000 div2 (virtual)

D题，这个思想和前面20250227的B题很像，题目意思是两条直线 `y=0` 和 `y=2` 上有很多给定的点，可以任选不共线的三点构成三角形（选点不可重复），最多能选出 `k_max` 个三角形，请问 `k_max` 的值，以及对于每一个 `1 - k_max` 的值，所选取三角形最大总面积是多少？

其实还是转换是思想，两条直线上怎么选点、选哪些点能让总面积最大是不好直接确定的，但是如果转换为，定义 `g(m, n)`，m 代表有 m 个三角形的两个点来自 `y=0`，n 个三角形的两个点来自于 `y=2`，这样就可以确定最大面积了！如果给定选 k 个三角形，相当于求 :

$$
max(g(x, k - x)), x\in(0,k)
$$

然后就可以利用 `tenary search` 搜素这个可能的单峰最大值，从而降低复杂度，妙哉！

虽然有个小问题是，到底怎么想到 `g(x, k - x)` 是单峰函数的？

#### 2025 0316 cf_round1010 div2

C题，是一个期望的题目，说是对于一个数 $k$，每次可以分别以 $\frac{1}{2}$ 的概率选择除2上取整，和除2下取整，操作 $x$ 次后变为 1，问 $x$ 的期望，题解也是令人难以理解

实际上，如果 $k$ 的二进制位数为 $n$，那么操作次数只有可能为 $n$, $n - 1$ 两种，并且如果为 $n$ 那么一定在除以2的过程中，二进制数发生了进位（我们将除以2这一操作理解为将二进制数的最后一位消除，因此才有可能有进位这一说法），那么我们以 $f_i$ 代表 $i$ 位之前发生进位的概率，就有递推关系：

$$
f_i =
\begin{cases} 
\frac{1}{2} \times f_{i-1}, & k_i = 0 \\[10pt]
\frac{1}{2} \times (1 - f_{i-1}) + f_{i-1}, & k_i = 1
\end{cases}
$$

最后答案就是 $n - 1 + f_{n -1}$ , 虽然不好理解！很神奇的一道题！

#### 2025 0318 cf_eduround176 div2

C题，是一个思维转换的题目，题目意思说，有 n 个方块, m 种颜色，每种颜色可以涂 $a_j$ ($1 <= j <= m$) 个方块，现在要把这一排 n 个方块分成两部分，左边部分和右边部分涂不同的颜色，问一共多少种涂法

contest 的时候我的思维陷进去了，我一直在想怎么枚举所有 2 种不同颜色的组合，但是会非常复杂，最后还是过不了，但是题解给另一种及其巧妙的做法，不是枚举不同颜色的组合，而是枚举怎么分成这两部分，也就是左边部分有 i 块，右边有 n - i 块，枚举这个 i 就行，会方便很多，只要先排序 $a_j$，然后二分出合法的组合类种数，对于每个 i 找出合法 j 的数量 x 和 n - j 的数量 y，再减去重复的 $min(x, y)$, $x \times y - min(x, y)$ 就是 i 的贡献

巧妙的思维转换直接让这题变得简单许多倍！

#### 2025 0322 cf_round1011 div2

是一道描述很简单的数学题，给定 $x, y$ ，求 $k$ 使得 $(x + k) + (y + k) == (x + k) \ xor\ (y + k)$ 

怎么样理解异或运算是这道题的关键，在二进制运算中，上式等价于 $x \& y = 0$ ，也等价于二者的二进制不能有任何一位同时为1，因为同时为1会产生进位，同时，本题并没有要求最小 $k$，因此对于 $x,y$，只要取一个 2 的幂次方且比 $x, y$ 都大，就一定能满足上述条件，这也是一种思维转换！ 

#### 2025 0323 cf_round1012 div2

D题，是一道数学题，构造一个n的全排列，令 $c_k = \lceil\frac{\sum_{i=1}^{k}a_i}{k} \rceil$ ，要求 $c_k$ 中为质数的个数大于等于 $\lfloor \frac{n}{3} \rfloor - 1$ 个，刚开始一直比较严谨的想怎么构造，后来思维一转变，我直接找到距离 $\frac{n}{2}$ 最近的质数，然后就 $1, 2\times k-1,2,2\times k - 2 ...$ 这样可以保证前 2k 个数中有 k 个质数，只要 k >= $\frac{2n}{3}$  就能完成任务

还是思维要灵活、打开，不能局限于某一种特定思路

#### 2025 0403 cf_eduround177 div2

D题，这是一道组合数学题，给定26个字母每个字母在字符串 s 中的出现次数，并限制：相同字母之间的间隔必须是偶数，这也意味着，相同的字母要不然全部在奇数位上，要不然全部在偶数位上

核心在于 ：
$$
\frac{n_{odd}! \ n_{even}!}{n_1!n_2!...n_k!}
$$
其中 $n_{odd}$ , $n_{even} $ 是奇数位和偶数位数量，$n_i$ 是每个相同种类元素的个数

然后再用动态规划求出可能填充方案数，和上面的式子相乘就是答案

思考：为什么相乘就是答案？

妙哉

#### 2025 0404 Training

一道数论题，对于一个序列 $a_n$，给定序列长度 $n$ 和一个数 $k$，进行操作：任意选择 $l, r$ 并让该区间内所有数加 $k$，问：一次操作后，整个序列的最大公约数是多少？

这道题原本我想二分这个最大公约数，但是显然这样的思路歪了，因为二分一定要具有单调性，但是 gcd 是非线性的根本无法保证单调性，后来又想 dp，但是还是一样的问题，gcd 没有办法递推

最后看了题解，看见了从未设想过的思路 :cry:

对于整个序列的 gcd，可以分为：$G_1= gcd(a_1, ...a_{l-1}), G_2= \ gcd(a_l, ....a_r), G_3= \ gcd(a_r,... a_n)$ 三个部分然后取 gcd，$G_1$ 是前缀 gcd，而且有一个隐藏性质，因为 $a_i$ 是小于 $10^{18}$的，对于每一次前缀 gcd 运算，都至少让这个值减少了 $\frac{1}{2}$ ，因此，这个前缀 gcd 数组最多有 $log_2{10^{18}}$ <= 64 个值，这也意味着，可以依次枚举这些不同的值！

再来看 $G_1, G_2$ 的递增递减规律，随着 $l$ 的增加，$G_1$ 的值一定在减少，而 $G_2$ 的值一定在增加，而由上面的推导知， $G_1$ 的值呈阶梯状，因此我们可以枚举每个让 $G_1$ 即将下降的位置，然后再枚举每一个 $r$，这样复杂度就是 $O(64n)$ :happy:

magic!

#### luoguP1064

0-1背包问题使用空间压缩时，循环必须倒序（想想为什么？），不然会重复选！

同样的道理，完全背包问题使用空间压缩的时候，循环必须正序！

#### luoguP2303

快速方法求
$$
\sum_{i=1}^n gcd(i,n)
$$
其中 $n < 2^{31}$

欧拉函数化简后仍然超时，如何化简？
$$
\sum \gcd(i, n) = \sum_{j=1}^n j \sum_{i=1}^n [\gcd(i,n)=j]
= \sum_{j \mid n} j \cdot \varphi(n/j)
$$

对于一个数 n 而言，其因数是关于 $\sqrt{n}$  呈几何对称分布的，因此 $\sum_{j \mid n} j \cdot \varphi(n/j) = \sum_{j \mid n} \frac{n}{j} \varphi(j)$ 
$$
= \sum_{j \mid n} \frac{n}{j} \varphi(j)
= \sum_{j \mid n} \left( \frac{n}{j} \cdot j \cdot \prod_{p \mid j} \frac{p-1}{p} \right)
= n \sum_{j \mid n} \prod_{p \mid j} \frac{p-1}{p}
$$

$$
n = p_1^{b_1} p_2^{b_2} p_3^{b_3} \cdots p_k^{b_k}
$$

$$
j = p_1^{c_1} p_2^{c_2} p_3^{c_3} \cdots p_k^{c_k}, \quad 0 \leq c_i \leq b_i
$$

$$
\prod_{i=1}^k \left( \frac{p_i - 1}{p_i} \right)^{[c_i > 0]}
$$

$$
于是原式化简为\  n \cdot \prod_{i=1}^k \frac{b_i p_i - b_i + p_i}{p_i}
$$

之所以能化简到这一步，是==逆向借助了乘法分配律==，因为该式实际上是：
$$
n \cdot \prod_{i=1}^k (\frac{b_i (p_i - 1)}{p_i} + 1)
$$
非常重要的思想！！！



#### 2025 0419 cf_round1017 div4

G题

对于一个数组 a

计算
$$
\sum_{i=1}^n i \times a[i]
$$
的一些性质？

如果这时候突然反转这个数组？或者末尾添加一个元素？或者循环移位操作？

对于 q 次操作和查询，怎么在最低的时间复杂度得到这些值？

==队列！高效的实现循环移位！==

==开两个队列！元素对倒！高效的实现反转数组！==

再引申：

如果计算的是
$$
\sum_{i=1}^k i \times sum(a[l_i, r_i])
$$
也就是把a分成了k段，然后计算上述式子，此时如果：对某一个段再次切分变成 k+1 段，值会怎么变？

==后缀和！==

如果问对于一个数组 a，怎么样切分能让每一次切分时，上述式子都最大？

==后缀和排序！==



#### 2025 0420 cf_round1018 div1+2 

C题，非常nb的一道dp+差分的题目

给定一个n*n矩阵，要求做修改，让相邻元素的值不能相同：现在给定数组 a(n), b(n)，其元素 $a_i$ 代表第 i 行所有元素全部加1的代价，元素 $b_i$ 代表第 i 列所有元素全部加1的代价，且均只能使用一次，现在求最小代价

先分别差分行、列，分成两个矩阵，并且发现这两个矩阵是可以独立处理的：即只需要差分矩阵中没有元素为0即可

对原矩阵第 i 行中所有元素全部加1，相当于对差分矩阵的第 i - 1 行减1，第 i 行加1，这样就可以按照条件进行dp！！！

开一个二维dp[n]/[2], 第二个维度代表当前行需不需要执行 +1 操作，并且执行这个操作是需要条件的！ 

先贴代码：

```` cpp
	vector<vector<ll> > dpR(n + 1, vector<ll>(2, INF));
    dpR[1][0] = 0;
    dpR[1][1] = score_row[1];
    for(int i = 1; i < n; ++i){
        for(int s = 0; s < 2; ++s){
            if(dpR[i][s] == INF) continue;
            for(int t = 0; t < 2; ++t){        // 这里的两层 for 循环就是分别固定住状态，然后判断是否可行！
                ll delta = t - s; 
                bool ok = false;
                if(delta == 0) 
                    ok = same_row[i];
                else if(delta == 1) 
                    ok = rise_row[i];
                else if(delta == -1) 
                    ok = fall_row[i];
                if(!ok) 
                    continue;
                ll cost = (t ? score_row[i + 1] : 0LL);
                if(dpR[i + 1][t] > dpR[i][s] + cost){
                    dpR[i + 1][t] = dpR[i][s] + cost;
                }
            }
        }
    }
    ll bestR = min(dpR[n][0], dpR[n][1]);
````

可以发现，我们==分别固定第 i ，i+1 行的第二个状态，此时再根据条件判断第 i 行是否可行，如果可行就更新 dp 的值==，否则视为 INF！

这种思想和之前的二分，固定值后再 check 想法很类似！

本题卡住我的另一个小 trick：差分时到底是 `a[i+1]-a[i]` 还是 `a[i]-a[i-1]`?  这个问题看似不重要，但是却影响了 dp 的递推式

如果本题改为另一种差分方式，那在 dp 中，就会是用第 i-1 和 i 行的第二个状态去判断第 i 行是否可行！ 



#### luoguP6583

计算区间 [l, r] 内，拥有因子 a 或 b 的数的数量：==容斥原理==

如果是计算区间内 拥有因子a的数量：	
$$
\lfloor \frac {r}{x} \rfloor - \lfloor \frac {l-1}{x} \rfloor
$$

```c++
int count_in_range(int l, int r, int x) {
    return count_multiples(r, x) - count_multiples(l - 1, x);
}   // 计算区间内拥有因子 x 的数的数量

int result = count_in_range(l, r, a) + count_in_range(l, r, b) - count_in_range(l, r, a*b);
// 容斥原理核心
```

当然，这是只是本题的一个小tricks

题干为：

给定 n，若 $1 \leq x, y \leq n$, 请问有多少组满足条件的 $\frac{x}{y}$ 是可以有限表示的小数？$n \leq 10^{12}$

首先明确的是有限表示的小数，意味着和 2，5 两个因子有关系

一通推导，发现和数论分块有关

但是写的方法还是被卡了，没有达到最优，折磨我一晚上 :cry:

代码文件：[P6583](D:\ProgrammingProject\ACMPractice\other\luoguP6583.cpp)



#### 2025 0422 cf_round1019 div2

C题

又被卡了，哎 :crying_cat_face:

给定一个数组，然后分成三个非空的部分，定义 $med(a_l,..., a_r)$，且这个子数组的大小为 $m$, 那么该值等于第 $\lceil \frac {m}{2} \rceil$ 小的元素值

判断是否存在这样一个划分，让 $med(med(a_1, ... ,a_l-1), med(a_l,..., a_r), med(a_r+1, ...,a_n))$ 的值小于给定的 $k$

其实还是思路没转变过来

一个数组的 med 值小于k，相当于该数组至少有一半的数小于等于k，但是至于这个数具体是多少，是无所谓的，因此，我们可以直接将大于k的赋值为1，小于k的赋值为-1，然后计算数组的prefix（$a_r - a_{l-1}$），只要大于等于0，就代表该前缀数组是满足条件的；

同时，划分后三个部分的 med 小于等于k，意味着至少有2个部分是小于等于k，这个时候就想到：直接穷举，依次枚举几种可能；并且，前缀+中间部分、后缀+中间部分是对称的

还有一个tricks，也是我之前的思路无法做到的一点，==就是求前缀和数组的后缀最大值==，并开一个数组 $msp(max\ suffix\ prefix)$，因此，当我们判断 前缀+中间部分 的时候，我们可以遍历 $1 - (n-2)$ 中的所有元素，如果前缀和大于等于0，并且下一个数的后缀最大值是大于 prefix[i] 的，那就代表前缀+中间部分可以满足条件！
